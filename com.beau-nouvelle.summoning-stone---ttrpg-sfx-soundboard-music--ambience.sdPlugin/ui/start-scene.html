<!DOCTYPE html>
<html>

<head lang="en">
	<title>Start Scene Settings</title>
	<meta charset="utf-8" />
	<script src="https://sdpi-components.dev/releases/v4/sdpi-components.js"></script>
	<style>
		.status {
			color: #cccccc;
			font-size: 12px;
			margin: 8px 0 0 0;
		}
	</style>
</head>

<body>
	<sdpi-item label="Campaign">
		<sdpi-select id="campaign-select" disabled></sdpi-select>
	</sdpi-item>
	<sdpi-item label="Scene">
		<sdpi-select id="scene-select" disabled></sdpi-select>
	</sdpi-item>
	<sdpi-item>
		<sdpi-button id="retry-button">Retry Connection</sdpi-button>
	</sdpi-item>
	<p class="status" id="status"></p>

	<script>
		const API_BASE_URL = "http://127.0.0.1:7123";
		const campaignSelect = document.getElementById("campaign-select");
		const sceneSelect = document.getElementById("scene-select");
		const statusEl = document.getElementById("status");
		const retryButton = document.getElementById("retry-button");

		let websocket = null;
		let uuid = null;
		let actionContext = null;
		let settings = {};
		let campaigns = [];
		let scenes = [];
		let retryTimer = null;
		let lastCampaignValue = "";
		let lastSceneValue = "";
		let isLoadingCampaigns = false;
		let hasLoadedCampaigns = false;
		let loadedCampaignId = "";
		let isApplyingSettings = false;

		function setStatus(message) {
			statusEl.textContent = message || "";
		}

		function scheduleRetry() {
			if (retryTimer) return;
			retryTimer = window.setTimeout(() => {
				retryTimer = null;
				loadCampaigns();
			}, 5000);
		}

		function clearRetry() {
			if (retryTimer) {
				window.clearTimeout(retryTimer);
				retryTimer = null;
			}
		}

		function setSelectsEnabled(enabled) {
			campaignSelect.disabled = !enabled;
			sceneSelect.disabled = !enabled;
		}

		function setCampaignPlaceholder(label) {
			campaignSelect.innerHTML = "";
			const placeholder = document.createElement("option");
			placeholder.value = "";
			placeholder.textContent = label;
			campaignSelect.appendChild(placeholder);
		}

		function setScenePlaceholder(label) {
			sceneSelect.innerHTML = "";
			const placeholder = document.createElement("option");
			placeholder.value = "";
			placeholder.textContent = label;
			sceneSelect.appendChild(placeholder);
		}

		async function fetchJson(path) {
			const controller = new AbortController();
			const timeoutId = window.setTimeout(() => controller.abort(), 3000);
			try {
				const response = await fetch(`${API_BASE_URL}${path}`, { signal: controller.signal });
				if (response.status === 401) {
					throw new Error("Please sign in to Summoning Stone to load scenes.");
				}
				if (!response.ok) {
					throw new Error(`Unexpected response (${response.status}).`);
				}
				return await response.json();
			} catch (error) {
				if (error?.name === "AbortError") {
					throw new Error("Request timed out. Is Summoning Stone open?");
				}
				throw error;
			} finally {
				window.clearTimeout(timeoutId);
			}
		}

		function connectElgatoStreamDeck(inPort, inUUID, inRegisterEvent, inInfo, inActionInfo) {
			uuid = inUUID;
			if (inActionInfo) {
				try {
					const payload = typeof inActionInfo === "string" ? JSON.parse(inActionInfo) : inActionInfo;
					actionContext = payload?.context || null;
					settings = payload?.payload?.settings || {};
				} catch (error) {
					settings = {};
				}
			}

			websocket = new WebSocket(`ws://127.0.0.1:${inPort}`);
			websocket.onopen = () => {
				websocket.send(JSON.stringify({ event: inRegisterEvent, uuid }));
				requestSettings();
				loadCampaigns();
			};
			websocket.onmessage = (event) => {
				const message = JSON.parse(event.data);
				if (message.event === "didReceiveSettings") {
					settings = message.payload.settings || {};
					void updateSelections();
				}
			};
		}

		function requestSettings() {
			if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
			const context = actionContext || uuid;
			websocket.send(JSON.stringify({ event: "getSettings", context }));
		}

		function setSettings(patch) {
			settings = { ...settings, ...patch };
			if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
			const context = actionContext || uuid;
			websocket.send(JSON.stringify({ event: "setSettings", context, payload: settings }));
		}

		async function loadCampaigns() {
			if (isLoadingCampaigns) return;
			isLoadingCampaigns = true;
			clearRetry();
			setStatus("Loading campaigns...");
			setSelectsEnabled(false);
			setCampaignPlaceholder("Loading...");
			setScenePlaceholder("Select a scene");
			try {
				campaigns = await fetchJson("/campaigns");
				populateCampaigns();
				await loadScenes(settings.campaignId);
				await updateSelections();
				setStatus("");
				setSelectsEnabled(true);
				hasLoadedCampaigns = true;
			} catch (error) {
				const message = error?.message || "Unable to load campaigns.";
				setCampaignPlaceholder("Summoning Stone not connected");
				setScenePlaceholder("Select a scene");
				setStatus(`${message} Open the Summoning Stone app to continue. Retrying...`);
				scheduleRetry();
			} finally {
				isLoadingCampaigns = false;
			}
		}

		async function loadScenes(campaignId) {
			scenes = [];
			if (!campaignId) {
				loadedCampaignId = "";
				populateScenes();
				return;
			}
			setStatus("Loading scenes...");
			try {
				scenes = await fetchJson(`/campaigns/${encodeURIComponent(campaignId)}/scenes`);
				populateScenes();
				loadedCampaignId = campaignId;
				setStatus("");
			} catch (error) {
				populateScenes();
				loadedCampaignId = "";
				const message = error?.message || "Unable to load scenes for this campaign.";
				setStatus(message);
			}
		}

		function populateCampaigns() {
			setCampaignPlaceholder("Select a campaign");

			campaigns.forEach((campaign) => {
				const option = document.createElement("option");
				option.value = campaign.id;
				option.textContent = campaign.name;
				campaignSelect.appendChild(option);
			});
		}

		function populateScenes() {
			setScenePlaceholder("Select a scene");

			scenes.forEach((scene) => {
				const option = document.createElement("option");
				option.value = scene.id;
				option.textContent = scene.name;
				sceneSelect.appendChild(option);
			});
		}

		async function updateSelections() {
			if (campaigns.length) {
				isApplyingSettings = true;
				campaignSelect.value = settings.campaignId || "";
				isApplyingSettings = false;
			}
			if (settings.campaignId && loadedCampaignId !== settings.campaignId && !isLoadingCampaigns) {
				await loadScenes(settings.campaignId);
			}
			if (scenes.length) {
				isApplyingSettings = true;
				sceneSelect.value = settings.sceneId || "";
				isApplyingSettings = false;
			}
		}

		async function handleCampaignChange() {
			if (isApplyingSettings || !campaigns.length) return;
			const currentValue = campaignSelect.value;
			if (currentValue === lastCampaignValue) return;
			lastCampaignValue = currentValue;
			const selected = campaigns.find((campaign) => campaign.id === currentValue);
			setSettings({
				campaignId: selected?.id,
				campaignName: selected?.name,
				sceneId: undefined,
				sceneName: undefined,
			});
			await loadScenes(selected?.id);
			sceneSelect.value = "";
		}

		campaignSelect.addEventListener("change", handleCampaignChange);
		campaignSelect.addEventListener("input", handleCampaignChange);
		campaignSelect.addEventListener("valuechange", handleCampaignChange);

		function handleSceneChange() {
			if (isApplyingSettings || !scenes.length) return;
			const currentValue = sceneSelect.value;
			if (currentValue === lastSceneValue) return;
			lastSceneValue = currentValue;
			const selected = scenes.find((scene) => scene.id === currentValue);
			setSettings({
				sceneId: selected?.id,
				sceneName: selected?.name,
			});
		}

		sceneSelect.addEventListener("change", handleSceneChange);
		sceneSelect.addEventListener("input", handleSceneChange);
		sceneSelect.addEventListener("valuechange", handleSceneChange);

		retryButton.addEventListener("click", () => {
			loadCampaigns();
		});

		function ensureCampaignsLoaded() {
			if (hasLoadedCampaigns || isLoadingCampaigns) return;
			loadCampaigns();
		}

		window.addEventListener("load", ensureCampaignsLoaded);
		document.addEventListener("visibilitychange", () => {
			if (!document.hidden) {
				ensureCampaignsLoaded();
			}
		});

		window.connectElgatoStreamDeck = connectElgatoStreamDeck;

		setCampaignPlaceholder("Loading...");
		setScenePlaceholder("Loading...");
		setStatus("Waiting for Stream Deck...");
	</script>
</body>

</html>
